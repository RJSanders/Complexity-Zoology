# This algorithm computes the quotient map q of the equivalence relation
# generated by a graph G. P is a set of preferred names for the various classes.
# If there is no element of P for an equivalence class, the algorithm chooses
# its own.
def union_find(G, P):
    q = {}
    R = set()
    for x in G:
        q[x] = x
        R.add(x)

    for x in G:
        for y in G[x]:
            if q[x] == q[y]: continue

            if q[x] in P and q[y] in P:
                print('Error: redundant preferred names.')
                print(x)
                print(y)
                quit()

            if q[x] in P or len(q[y].split('.')) > 1:
                w = q[y]
                for z in q:
                    if q[z] == w: q[z] = q[x]
                R.remove(w)
            else:
                w = q[x]
                for z in q:
                    if q[z] == w: q[z] = q[y]
                R.remove(w)

    return (q, R)

def main(classes_keywords, props, operators, classes):
    P = set()
    for name in classes_keywords:
        if 'preferred' in classes_keywords[name]: P.add(name)
        if 'symmetric' in classes_keywords[name]:
            props['='][name].add('co.' + name)
            props['='][name].add('cocap.' + name)

    for name in classes:
        if name not in props['=']: props['='][name] = set()

    for x in props['=']:
        for y in props['='][x]:
            for op in operators:
                n1 = op + '.' + x
                n2 = op + '.' + y
                if n1 in classes and n2 in classes: props['='][n1].add(n2)

    (q, names) = union_find(props['='], P)

    return (props, q, names)
